#define OP(i) (((i) - (pool))^1)
class sap
{
private:
    const static int V = 20010, E = 1000000, INF = 100000000;
    int dis[V], numdis[V], pre[V], maxflow;;
    bool reachS[V], reachT[V];
    struct edge
    {
        int v, cap;
        edge *nxt;//e保存当前弧，pree存可行流中的边
    } pool[E], *g[V], *pp, *e[V], *pree[V];
    void bfs(int v, int n)//从汇点开始按照反向边流量走
    {
        int que[V], tail = 0;
        bool vst[V] = {0};
        memset(numdis, 0, sizeof(numdis));
        fill(dis, dis + n, n);
        dis[v] = 0, vst[v] = 1, que[0] = v;
        for (int j = 0; j <= tail; j++)
        {
            int tmp = que[j % n];
            for (edge *i = g[tmp]; i != NULL; i = i->nxt)
            {
                if (pool[OP(i)].cap > 0 && !vst[i->v])
                {
                    tail++;
                    vst[i->v] = 1;
                    que[tail % n] = i->v;
                    dis[i->v] = dis[tmp] + 1;
                    numdis[dis[i->v]]++;
                }
            }
        }
    }
    int findArgumentPath(int &v, int s, int t)
    {
        while (e[v] != NULL)
        {
            if (e[v]->cap > 0 && dis[v] == dis[e[v]->v] + 1)
            {
                pre[e[v]->v] = v, pree[e[v]->v] = e[v], v = e[v]->v;
                if (v == t)
                {
                    int minf = INF;
                    for (int i = t; i != s; i = pre[i])
                        minf = min(minf,pree[i]->cap);
                    for (int i = t; i != s; i = pre[i])
                    {
                        pree[i]->cap -= minf;
                        pool[OP(pree[i])].cap += minf;
                    }
                    v = s;
                    return minf;
                }
            }
            else e[v] = e[v]->nxt;
        }
        return 0;
    }
public:
    int maxflowsap(int n, int s, int t)
    {
        bfs(t, n);
        int v = s;
        copy(g, g + n, e);
        while (dis[s] < n)//标号为n 表示无可行流
        {
            int add = findArgumentPath(v, s, t);
            maxflow += add;
            if (add == 0)//发现某个点v没有允许弧，维护其距离标号
            {
                int mindis = n;
                numdis[dis[v]]--;
                if (!numdis[dis[v]]) break;//GAP 优化，发现断层直接退出
                for (edge *i = g[v]; i != NULL; i = i->nxt)
                    if (i->cap > 0) mindis = min(mindis,dis[i->v] + 1);
                dis[v] = mindis;
                numdis[dis[v]]++;
                e[v] = g[v];//改变距离标号以后从新维护当前弧，回前驱
                if (v != s) v = pre[v];
            }
        }
        return maxflow;
    }
    void firststart()
    {
        pp = pool;
        maxflow = 0;
        memset(g,0,sizeof(g));
        //memset(reachS, 0, sizeof(reachS));
        //memset(reachT, 0, sizeof(reachT));
    }//后两个用于求割等问题
    void addedge(int i, int j, int cap)
    {
        pp->v = j;
        pp->cap = cap;
        pp->nxt = g[i];
        g[i] = pp++;
    }//不自动加反向边，如果i to j j to i都有容量且相邻加入
    void dfss(int x)
    {
        reachS[x] = true;
        for(edge *i = g[x]; i != NULL ; i = i->nxt)
            if(i->cap && !reachS[i->v]) dfss(i->v);
    }//网络流割S-T割出来的S集合是从源点正向边遍历到的点集合
    void dfst(int x)
    {
        reachT[x] = true;
        for(edge *i = g[x]; i != NULL; i = i->nxt)
            if(pool[OP(i)].cap && !reachT[i->v]) dfst(i->v);
    }//用于求关键边等问题
    //关键边是一端reachS 一端reachT 且无流量的边
}maxflow;
