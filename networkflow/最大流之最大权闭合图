最大权闭合图：(闭合图是一个子图)
	在一个图中，我们选取一些点构成集合，记为V，且集合中的出边(即集合中的点的向外连出的弧)，所指向的终点(弧头)也在V中，则我们称V为闭合图。最大权闭合图即在所有闭合图中，集合中点的权值之和最大的V，我们称V为最大权闭合图。
建图都比较隐蔽，依靠的定理是最大流的最小割定理
建图：
	原图 G(E,V) 新图G(EN,VE)
	在原图点集的基础上增加源 s 和汇 t ；将原图每条有向边 <u,v> ∈ E 替换为容量为c(u,v) = ∞ 的有向边 <u,v> ∈ EN ；
	增加连接源 s 到原图每个正权点 v ( wv > 0) 的有向边s, v ∈ EN ，容量为 c( s, v) = wv ；
	增加连接原图每个负权点 v ( wv < 0) 到汇 t 的有向边v, t ∈ EN ，容量为 c(v, t ) = − wv 。
	其中，正无限 ∞ 定义为任意一个大于 ∑ wv 的整数。v∈V
	在该问题中，最小割是一个简单割（割中的每一个边都于s相连或者与t相连）,割开后的集合V1是就成了一个闭合图
	按照闭合图权的定义:权值为闭合图中正值点的权和减去负值点的权值和的绝对值 所以求闭合图V1的权 = sum（Ｖ(val > 0)） - cut
	取最小割即可
输出最大权闭合图：
	从ｓ做一次DFS,所有reach过的点，便是最大权闭合图中的点
代码：
bool chk[V];
void dfs(int x, int n)
{
        chk[x] = true;
        for (edge * i = g[x]; i != NULL; i = i->nxt)
        {
                if (!chk[i->v] && i->cap > 0)
                        dfs(i->v, n);
        }
}
int find_cut(int n)
{
        memset(chk, false, sizeof (chk));
        dfs(0, n);
        int ans = 0;
        for (int i = 1; i <= n; i++)
                ans += chk[i];
        return ans;
}

