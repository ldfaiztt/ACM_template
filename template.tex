\documentclass[a4paper,5pt,twocolumn,titlepage]{article}

\usepackage{CJK}
\usepackage{ifthen}         % logic options
\usepackage{color}          % color image and color definition
\usepackage{calc}           % do size calculations
\usepackage{listings}       % format source code
\usepackage{fancyhdr}
\lstset{language=C,showspaces=false,showstringspaces=false,%
tabsize=4,extendedchars=false,columns=fullflexible,%
escapeinside={/*@}{@*/}}
\usepackage{times}
\usepackage{lastpage}
\usepackage[a4paper, body={15true cm,25.5true cm},%
            headheight=4true cm]{geometry}
\usepackage[CJKbookmarks,bookmarks=true,linkcolor=black,citecolor=black,%
            pagecolor=black,colorlinks=true]{hyperref}

% style: list typesetting
\definecolor{grey}{rgb}{0.3,0.3,0.3}
\definecolor{darkgreen}{rgb}{0,0.3,0}
\definecolor{darkblue}{rgb}{0,0,0.3}
\lstset{%
% indexing
    numbers=left,
    numberstyle=\tiny,%
% character display
    showstringspaces=false,
    showspaces=false,%
    tabsize=2,%
% style
    frame=lines,%
    basicstyle=\tiny\ttfamily,%
    keywordstyle=\color{darkblue}\bfseries,%
    identifierstyle=,%
    commentstyle=\color{darkgreen},%\itshape,%
    stringstyle=\color{grey}%
} \lstloadlanguages{C,C++,Java,Pascal}

\lstset{breaklines} \columnsep 1 cm \pagestyle{fancy}
\fancyhead[L]{Harbin Institute of Technology}
\fancyhead[R]{\thepage} \fancyfoot{}
\title{Team Reference Document}
\author{Encore @ Harbin Institute of Technology}
\begin{document}
\begin{CJK*}{GBK}{song}
\maketitle \tableofcontents
\newpage
\pagenumbering{arabic}
\section{String Processing}
\subsection{AC Automaton}
\lstinputlisting[language=C++]{string/ACAutomaton.cpp}
\subsection{Suffix Array}
\lstinputlisting[language=C++]{string/SuffixArray.cpp}
\subsection{Suffix Automaton}
\lstinputlisting[language=C++]{string/SuffixAutomaton.cpp}
\subsection{KMP}
\lstinputlisting[language=C++]{string/KMP.cpp}
\subsection{Algorithm Z}
\lstinputlisting[language=C++]{string/ExtendKMP.cpp}
\section{Network Flow}
\subsection{Max flow}
\lstinputlisting[language=C++]{networkflow/sap.cpp}
\subsection{Cost flow}
\lstinputlisting[language=C++]{networkflow/mincost.cpp}
\section{Data Structure}
\subsection{DLX exact cover}
\lstinputlisting[language=C++]{dataStructure/DLX(exact).cpp}
\subsection{DLX fuzzy cover}
\lstinputlisting[language=C++]{dataStructure/DLX(fuzzy).cpp}
\subsection{Partition Tree}
\lstinputlisting[language=C++]{dataStructure/partition_tree.cpp}
\subsection{Leftist Tree}
\lstinputlisting[language=C++]{dataStructure/leftist_tree.cpp}
\subsection{Cartesian Tree}
\lstinputlisting[language=C++]{dataStructure/Cartesian_Tree.cpp}
\subsection{Splay}
\lstinputlisting[language=C++]{dataStructure/Splay.cpp}
\section{Graph Theory}
\subsection{2-Satisfiability}
\lstinputlisting[language=C++]{graph/connection/2_sat.cpp}
\subsection{Edge Cut}
\lstinputlisting[language=C++]{graph/connection/E_BCC.cpp}
\subsection{Vertex Cut}
\lstinputlisting[language=C++]{graph/connection/BCC.cpp}
\subsection{Hopcroft Karp}
\lstinputlisting[language=C++]{graph/match/Hopcroft-Karp.cpp}
\subsection{Hungary Algorithm}
\lstinputlisting[language=C++]{graph/match/Hungary.cpp}
\subsection{KM}
\lstinputlisting[language=C++]{graph/match/KM.cpp}
\subsection{Stable Marriage}
\lstinputlisting[language=C++]{graph/match/StableMarriage.cpp}
\subsection{Maximum Clique}
\lstinputlisting[language=C++]{graph/other/MaximumClique.cpp}
\subsection{Maximal Clique}
\lstinputlisting[language=C++]{graph/other/BronKerbosch.cpp}
\subsection{Lowest Common Ancestor}
\lstinputlisting[language=C++]{graph/other/LCA.cpp}
\subsection{Minimum Cut Algorithm}
\lstinputlisting[language=C++]{graph/other/StoerWagner.cpp}
\subsection{Degree-constrained Spanning Tree}
\lstinputlisting[language=C++]{graph/spanningTree/dgrMST.cpp}
\subsection{Minimum Directed Tree}
\lstinputlisting[language=C++]{graph/spanningTree/MDT(pool).cpp}
\section{Dynamic Programing}
\subsection{Mask DP I}
\lstinputlisting[language=C++]{DynamicPrograming/mask_DP_I.cpp}
\subsection{Mask DP II}
\lstinputlisting[language=C++]{DynamicPrograming/mask_DP_II.cpp}
\section{Math}
    \subsection{Matrix}
        \lstinputlisting[language=C++]{Source/Math/Matrix/Matrix.txt}
    \subsection{Number Thoery}
        \subsubsection{Phi}
             \lstinputlisting[language=C++]{Source/Math/NumberThoery/phi.txt}
        \subsubsection{$a^x == b(mod n)$}
            $a^x=b(mod p)$ p is prime number:Baby-step-gaint-step
            \lstinputlisting[language=C++]{Source/Math/NumberThoery/babyStep.txt}
            $a^x=b(mod n)$ a,b,n can be any integer.Baby-step-gaint-step
            \lstinputlisting[language=C++]{Source/Math/NumberThoery/extend_baby_step.txt}
        \subsubsection{$x*x == a (mod p)$}
            \lstinputlisting[language=C++]{Source/Math/NumberThoery/square_roots_in_zq.txt}
        \subsubsection{Miller and Pollard}
            \lstinputlisting[language=C++]{Source/Math/NumberThoery/p_rho.txt}
        \subsubsection{Get prime in range}
            \lstinputlisting[language=C++]{Source/Math/NumberThoery/getPrimeInRange.txt}
        \subsubsection{Mod Equation}
             \lstinputlisting[language=C++]{Source/Math/NumberThoery/MEquation.txt}
    \subsection{Fraction}
        \subsubsection{$a/b < x/y < c/d$}
         \lstinputlisting[language=C++]{Source/Math/Fraction/middle_fraction.cpp}
         \subsubsection{$x^2 - n*y^2 = 1$}
         $n$ is a non-squre-number, solve the minimum $(x1,y1)$\\
         all $(x_i,y_i)$ satisfies:
         $$x_i + y_i\sqrt n = (x_1 + y_1\sqrt n)^i$$
         $$x_{i+1} = x_1x_i + ny_1y_i$$
         $$y_{i+1} = x_1y_i + y_1x_i$$
         \lstinputlisting[language=C++]{Source/Math/Fraction/pell_equation.cpp}
         \subsubsection{$\sum_{k=0}^{n-1}\lfloor (a+d*k)/m \rfloor$}
         \lstinputlisting[language=C++]{Source/Math/Fraction/gauss_sum.cpp}
    \subsection{Linear Equaton}
        \subsubsection{Xor Equation}
             1 1 0 0 = 0 (here when r = 0, i = 0)\\
             0 0 1 0 = 1 (here when r = 1, i = 2)\\
             0 0 0 1 = 1 (here when r = 2, i = 3)\\
            \lstinputlisting[language=C++]{Source/Math/xorEquation.txt}
            be carefully when use long long and int
            \lstinputlisting[language=C++]{Source/Math/xorEquation_bit.txt}
        \subsubsection{Equation in Z}
        if in Q , change integer to fracton and no clean()
            \lstinputlisting[language=C++]{Source/Math/GuassInZ.txt}
        \subsubsection{Equation in R}
            \lstinputlisting[language=C++]{Source/Math/GuassInR.txt}
        \subsubsection{det}
            \lstinputlisting[language=C++]{Source/Math/det.txt}
       \subsection{Anti-Nim}
       Anti-Nim:\
    $res = \oplus _{i} sg(i)$ \\
    $cnt  = \sum_{i} [sg(i) <= 1]$\\
    first player wins when ($res = 0$ and $cnt = n$) $\parallel$ ($res \neq 0$ and $ cnt \neq n$)
       \subsection{nim multiply}
        $x \otimes y$ = mex \{$(x \otimes a) \oplus (b \otimes y) \oplus (a \otimes b)|0 \leq a < x, 0 \leq b < y$\}
        \lstinputlisting[language=C++]{Source/Math/nim_mult.txt}
    \subsection{FFT}
        \lstinputlisting[language=C++]{Source/Math/FFT.txt}
\section{Geometry}
\subsection{3D Convexhull}
\lstinputlisting[language=C++]{Source/Geometry/convexhull-center.cpp}
\subsection{2D Convexhull}
\lstinputlisting[language=C++]{Source/Geometry/graham.cpp}
\subsection{Points in triangle}
\lstinputlisting[language=C++]{Source/Geometry/graham.cpp}
\end{CJK*}
\end{document}
